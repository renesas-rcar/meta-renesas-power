From c352f232654c79fbe6f7ae46ddffc2f7c267519c Mon Sep 17 00:00:00 2001
From: Dietmar Eggemann <dietmar.eggemann@arm.com>
Date: Mon, 21 Nov 2016 16:38:09 +0000
Subject: [PATCH 39/92] arm64: Make cpufreq policy notifier usable for
 frequency-invariant load-tracking support

The maximum supported frequency of a cpu (policy->cpuinfo.max_freq) has
to be retrieved for frequency-invariant load-tracking.

This can be achieved by coding this functionality into the existing
cpufreq policy notifier (init_cpu_capacity_notifier) which is currently
only used for setting up dt-based cpu capacities (cpu node property
(capacity-dmips-mhz).

But frequency-invariant load-tracking has to work whether cpu capacity
dt-parsing succeeded or not.

Change init_cpu_capacity_notifier in such a way that even if the parsing
of the cpu capacity information failed the notifier is called for each
cpufreq policy to be able to set the maximum supported frequency.

The continue statement in init_cpu_capacity_callback() makes sure that we
don't go on calculating cap_scale in case the capacity parsing failed. The
whole implementation makes only sense as soon the code to set the per-cpu
variable max_freq is introduced by the following patch
("arm64: Frequency-invariant load-tracking support").

Cc: Catalin Marinas <catalin.marinas@arm.com>
Cc: Will Deacon <will.deacon@arm.com>
Signed-off-by: Dietmar Eggemann <dietmar.eggemann@arm.com>
(cherry picked from commit c4e6eb1f2e7ada58bd538af2243809416c6538aa)
Signed-off-by: Gaku Inami <gaku.inami.xw@bp.renesas.com>
---
 arch/arm64/kernel/topology.c | 13 +++++++------
 1 file changed, 7 insertions(+), 6 deletions(-)

diff --git a/arch/arm64/kernel/topology.c b/arch/arm64/kernel/topology.c
index 91de9dd..3d27df1 100644
--- a/arch/arm64/kernel/topology.c
+++ b/arch/arm64/kernel/topology.c
@@ -185,7 +185,7 @@ static void normalize_cpu_capacity(void)
 	struct cpufreq_policy *policy = data;
 	int cpu;
 
-	if (cap_parsing_failed || cap_parsing_done)
+	if (cap_parsing_done)
 		return 0;
 
 	switch (val) {
@@ -197,13 +197,17 @@ static void normalize_cpu_capacity(void)
 			       cpus_to_visit,
 			       policy->related_cpus);
 		for_each_cpu(cpu, policy->related_cpus) {
+			if (cap_parsing_failed)
+				continue;
 			raw_capacity[cpu] = arch_scale_cpu_capacity(NULL, cpu) *
 					    policy->cpuinfo.max_freq / 1000UL;
 			capacity_scale = max(raw_capacity[cpu], capacity_scale);
 		}
 		if (cpumask_empty(cpus_to_visit)) {
-			normalize_cpu_capacity();
-			kfree(raw_capacity);
+			if (!cap_parsing_failed) {
+				normalize_cpu_capacity();
+				kfree(raw_capacity);
+			}
 			pr_debug("cpu_capacity: parsing done\n");
 			cap_parsing_done = true;
 			schedule_work(&parsing_done_work);
@@ -218,9 +222,6 @@ static void normalize_cpu_capacity(void)
 
 static int __init register_cpufreq_notifier(void)
 {
-	if (cap_parsing_failed)
-		return -EINVAL;
-
 	if (!alloc_cpumask_var(&cpus_to_visit, GFP_KERNEL)) {
 		pr_err("cpu_capacity: failed to allocate memory for cpus_to_visit\n");
 		return -ENOMEM;
-- 
1.9.1

